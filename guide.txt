employeesAPI CRUD Guide
=======================

Step-by-step implementation
---------------------------
0. Review the project structure (understand where each responsibility lives before editing files)

   Take a minute to familiarize yourself with the folders so you always know which file to touch for controllers, repositories, models, or configuration.

   - `Controllers/` → ASP.NET Core API controllers (`EmployeesController`). This is where you register routes with `[Route]`/`[HttpGet]` attributes, wire up dependencies via constructor injection, and keep your request/response logic so clients know which URL to call.
   - `Data/` → repositories and data access abstractions (`EmployeesRepository`). This layer encapsulates SQL commands, parameter binding, and result mapping so controllers never talk to the database directly.
   - `Models/` → entity and request DTO classes (`Employee`, `CreateEmployeeRequest`, `UpdateEmployeeRequest`). Use these types to enforce validation attributes and keep the contract between controllers and the repository explicit.
   - `Program.cs` → application entry point + service registrations. Configure dependency injection, middleware (Swagger, HTTPS redirection), and map the controllers here.
   - `appsettings*.json` → configuration, including the SQL connection string. Store `ConnectionStrings:DefaultConnection` and other environment-specific settings that repositories read via `IConfiguration`.
   - `employeesAPI.csproj` → project file with NuGet references (Swashbuckle, System.Data.SqlClient). Update this when new packages or target frameworks are required so builds pull in the right dependencies.

1. Install dependencies (add the NuGet packages needed for SQL Server access and API testing)

   Make sure the project references the libraries that enable raw SQL access and Swagger tooling; without them, later steps will fail to build.

   - Add the NuGet package `System.Data.SqlClient` to enable raw SQL Server access (see `employeesAPI.csproj`).
   - Keep `Swashbuckle.AspNetCore` for Swagger UI/testing.

   employeesAPI.csproj

```
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="System.Data.SqlClient" Version="4.8.5" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.6.2" />
  </ItemGroup>

</Project>
```

2. Configure the database connection (persist the SQL Server connection string that repositories consume)

   Storing the connection string in configuration keeps secrets out of code and lets every environment point to its own SQL Server.

   - Store the SQL Server connection string in `appsettings.json` (and optionally `appsettings.Development.json`) under `ConnectionStrings:DefaultConnection`.
   - Example configuration:

   appsettings.json

```
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Server=DESKTOP-HKRIGT4\\SQLEXPRESS;Database=db_sample;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True"
  }
}
```

3. Define models/DTOs (shape the entities and payloads your controller exchanges with clients)

   Clear models ensure the repository knows how to map SQL rows and the controller knows which fields to accept or return.

   - `Models/Employee.cs` mirrors the `Employees` table columns returned by GET/POST/PUT.
   - `Models/CreateEmployeeRequest.cs` and `Models/UpdateEmployeeRequest.cs` describe POST/PUT payloads with validation attributes.

   Models/Employee.cs

```
namespace employeesAPI.Models;

public sealed class Employee
{
    public int EmployeeId { get; init; }
    public string FirstName { get; init; } = string.Empty;
    public string LastName { get; init; } = string.Empty;
    public string? Email { get; init; }
    public DateTime HireDate { get; init; }
    public bool? IsActive { get; init; }
    public DateTime? CreatedAt { get; init; }
}
```

   Models/CreateEmployeeRequest.cs

```
using System.ComponentModel.DataAnnotations;

namespace employeesAPI.Models;

public sealed class CreateEmployeeRequest
{
    [Required]
    [StringLength(100)]
    public string FirstName { get; init; } = string.Empty;

    [Required]
    [StringLength(100)]
    public string LastName { get; init; } = string.Empty;

    [EmailAddress]
    [StringLength(150)]
    public string? Email { get; init; }

    [Required]
    public DateTime HireDate { get; init; }

    public bool? IsActive { get; init; }

    public DateTime? CreatedAt { get; init; }
}
```

   Models/UpdateEmployeeRequest.cs

```
using System.ComponentModel.DataAnnotations;

namespace employeesAPI.Models;

public sealed class UpdateEmployeeRequest
{
    [Required]
    [StringLength(100)]
    public string FirstName { get; init; } = string.Empty;

    [Required]
    [StringLength(100)]
    public string LastName { get; init; } = string.Empty;

    [EmailAddress]
    [StringLength(150)]
    public string? Email { get; init; }

    [Required]
    public DateTime HireDate { get; init; }

    public bool? IsActive { get; init; }

    public DateTime? CreatedAt { get; init; }
}
```

4. Build the data layer (implement the repository that talks to SQL Server using parameterized commands)

   This is where the app actually speaks to SQL Server; keeping it isolated behind an interface makes it testable and easy to swap later.

   - Create `Data/EmployeesRepository.cs` with an `IEmployeesRepository` interface and `SqlEmployeesRepository` implementation.
   - Implement `GetEmployeesAsync`, `CreateEmployeeAsync`, `UpdateEmployeeAsync`, and `DeleteEmployeeAsync` using parameterized SQL commands plus helper methods to map `SqlDataReader` rows into `Employee` objects.

   Data/EmployeesRepository.cs

```
using System.Data.SqlClient;
using employeesAPI.Models;

namespace employeesAPI.Data;

public interface IEmployeesRepository
{
    Task<IReadOnlyList<Employee>> GetEmployeesAsync(CancellationToken cancellationToken = default);
    Task<Employee> CreateEmployeeAsync(CreateEmployeeRequest request, CancellationToken cancellationToken = default);
    Task<Employee?> UpdateEmployeeAsync(int employeeId, UpdateEmployeeRequest request, CancellationToken cancellationToken = default);
    Task<bool> DeleteEmployeeAsync(int employeeId, CancellationToken cancellationToken = default);
}

public sealed class SqlEmployeesRepository : IEmployeesRepository
{
    private readonly string _connectionString;

    public SqlEmployeesRepository(IConfiguration configuration)
    {
        _connectionString = configuration.GetConnectionString("DefaultConnection")
            ?? throw new InvalidOperationException("Connection string 'DefaultConnection' was not found.");
    }

    public async Task<IReadOnlyList<Employee>> GetEmployeesAsync(CancellationToken cancellationToken = default)
    {
        await using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = "SELECT EmployeeId, FirstName, LastName, Email, HireDate, IsActive, CreatedAt FROM Employees";

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);

        var results = new List<Employee>();

        var employeeIdOrdinal = reader.GetOrdinal("EmployeeId");
        var firstNameOrdinal = reader.GetOrdinal("FirstName");
        var lastNameOrdinal = reader.GetOrdinal("LastName");
        var emailOrdinal = reader.GetOrdinal("Email");
        var hireDateOrdinal = reader.GetOrdinal("HireDate");
        var isActiveOrdinal = reader.GetOrdinal("IsActive");
        var createdAtOrdinal = reader.GetOrdinal("CreatedAt");

        while (await reader.ReadAsync(cancellationToken))
        {
            results.Add(MapEmployee(reader, employeeIdOrdinal, firstNameOrdinal, lastNameOrdinal,
                emailOrdinal, hireDateOrdinal, isActiveOrdinal, createdAtOrdinal));
        }

        return results;
    }

    public async Task<Employee> CreateEmployeeAsync(CreateEmployeeRequest request, CancellationToken cancellationToken = default)
    {
        await using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = @"
INSERT INTO Employees (FirstName, LastName, Email, HireDate, IsActive, CreatedAt)
OUTPUT INSERTED.EmployeeId, INSERTED.FirstName, INSERTED.LastName, INSERTED.Email,
       INSERTED.HireDate, INSERTED.IsActive, INSERTED.CreatedAt
VALUES (@FirstName, @LastName, @Email, @HireDate, @IsActive, @CreatedAt);";

        command.Parameters.AddWithValue("@FirstName", request.FirstName);
        command.Parameters.AddWithValue("@LastName", request.LastName);
        command.Parameters.AddWithValue("@Email", (object?)request.Email ?? DBNull.Value);
        command.Parameters.AddWithValue("@HireDate", request.HireDate);
        command.Parameters.AddWithValue("@IsActive", (object?)request.IsActive ?? DBNull.Value);
        command.Parameters.AddWithValue("@CreatedAt", (object?)request.CreatedAt ?? DateTime.UtcNow);

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);
        if (await reader.ReadAsync(cancellationToken))
        {
            return MapEmployee(reader);
        }

        throw new InvalidOperationException("Could not insert employee.");
    }

    public async Task<Employee?> UpdateEmployeeAsync(int employeeId, UpdateEmployeeRequest request, CancellationToken cancellationToken = default)
    {
        await using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = @"
UPDATE Employees
SET FirstName = @FirstName,
    LastName = @LastName,
    Email = @Email,
    HireDate = @HireDate,
    IsActive = @IsActive,
    CreatedAt = @CreatedAt
OUTPUT INSERTED.EmployeeId, INSERTED.FirstName, INSERTED.LastName, INSERTED.Email,
       INSERTED.HireDate, INSERTED.IsActive, INSERTED.CreatedAt
WHERE EmployeeId = @EmployeeId;";

        command.Parameters.AddWithValue("@EmployeeId", employeeId);
        command.Parameters.AddWithValue("@FirstName", request.FirstName);
        command.Parameters.AddWithValue("@LastName", request.LastName);
        command.Parameters.AddWithValue("@Email", (object?)request.Email ?? DBNull.Value);
        command.Parameters.AddWithValue("@HireDate", request.HireDate);
        command.Parameters.AddWithValue("@IsActive", (object?)request.IsActive ?? DBNull.Value);
        command.Parameters.AddWithValue("@CreatedAt", (object?)request.CreatedAt ?? DBNull.Value);

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);
        if (await reader.ReadAsync(cancellationToken))
        {
            return MapEmployee(reader);
        }

        return null;
    }

    public async Task<bool> DeleteEmployeeAsync(int employeeId, CancellationToken cancellationToken = default)
    {
        await using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = "DELETE FROM Employees WHERE EmployeeId = @EmployeeId";
        command.Parameters.AddWithValue("@EmployeeId", employeeId);

        var affected = await command.ExecuteNonQueryAsync(cancellationToken);
        return affected > 0;
    }

    private static Employee MapEmployee(SqlDataReader reader)
    {
        var employeeIdOrdinal = reader.GetOrdinal("EmployeeId");
        var firstNameOrdinal = reader.GetOrdinal("FirstName");
        var lastNameOrdinal = reader.GetOrdinal("LastName");
        var emailOrdinal = reader.GetOrdinal("Email");
        var hireDateOrdinal = reader.GetOrdinal("HireDate");
        var isActiveOrdinal = reader.GetOrdinal("IsActive");
        var createdAtOrdinal = reader.GetOrdinal("CreatedAt");

        return MapEmployee(reader, employeeIdOrdinal, firstNameOrdinal, lastNameOrdinal, emailOrdinal,
            hireDateOrdinal, isActiveOrdinal, createdAtOrdinal);
    }

    private static Employee MapEmployee(SqlDataReader reader, int employeeIdOrdinal, int firstNameOrdinal,
        int lastNameOrdinal, int emailOrdinal, int hireDateOrdinal, int isActiveOrdinal, int createdAtOrdinal)
    {
        return new Employee
        {
            EmployeeId = reader.GetInt32(employeeIdOrdinal),
            FirstName = reader.GetString(firstNameOrdinal),
            LastName = reader.GetString(lastNameOrdinal),
            Email = reader.IsDBNull(emailOrdinal) ? null : reader.GetString(emailOrdinal),
            HireDate = reader.GetDateTime(hireDateOrdinal),
            IsActive = reader.IsDBNull(isActiveOrdinal) ? null : reader.GetBoolean(isActiveOrdinal),
            CreatedAt = reader.IsDBNull(createdAtOrdinal) ? null : reader.GetDateTime(createdAtOrdinal)
        };
    }
}
```

5. Register services (wire repositories, controllers, and Swagger/OpenAPI in Program.cs)

   Dependency injection only works if the services are registered, so this step ties together the data layer and MVC pipeline.

   - In `Program.cs`, register `IEmployeesRepository` with DI (`AddScoped`) and ensure controllers/Swagger services are enabled.

   Program.cs

```
using employeesAPI.Data;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();
builder.Services.AddScoped<IEmployeesRepository, SqlEmployeesRepository>();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();
```

6. Create the API controller (map HTTP verbs to repository calls for CRUD operations)

   The controller translates HTTP requests into repository calls and returns typed responses, acting as the façade for clients.

   - `Controllers/EmployeesController.cs` exposes CRUD endpoints: `GET /api/employees`, `POST /api/employees`, `PUT /api/employees/{id}`, `DELETE /api/employees/{id}`.

   Controllers/EmployeesController.cs

```
using employeesAPI.Data;
using employeesAPI.Models;
using Microsoft.AspNetCore.Mvc;

namespace employeesAPI.Controllers;

[ApiController]
[Route("api/[controller]")]
public class EmployeesController : ControllerBase
{
    private readonly IEmployeesRepository _repository;

    public EmployeesController(IEmployeesRepository repository)
    {
        _repository = repository;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Employee>>> GetAsync(CancellationToken cancellationToken)
    {
        var employees = await _repository.GetEmployeesAsync(cancellationToken);
        return Ok(employees);
    }

    [HttpPost]
    public async Task<ActionResult<Employee>> CreateAsync([FromBody] CreateEmployeeRequest request, CancellationToken cancellationToken)
    {
        var employee = await _repository.CreateEmployeeAsync(request, cancellationToken);
        return Created($"/api/employees/{employee.EmployeeId}", employee);
    }

    [HttpPut("{id:int}")]
    public async Task<ActionResult<Employee>> UpdateAsync(int id, [FromBody] UpdateEmployeeRequest request, CancellationToken cancellationToken)
    {
        var employee = await _repository.UpdateEmployeeAsync(id, request, cancellationToken);
        if (employee is null)
        {
            return NotFound();
        }

        return Ok(employee);
    }

    [HttpDelete("{id:int}")]
    public async Task<IActionResult> DeleteAsync(int id, CancellationToken cancellationToken)
    {
        var deleted = await _repository.DeleteEmployeeAsync(id, cancellationToken);
        if (!deleted)
        {
            return NotFound();
        }

        return NoContent();
    }
}
```

7. Run and test (verify everything builds, runs, and responds via Swagger or external tools)

   Building and running confirms there are no compile/runtime errors, and manual testing checks the endpoints against a real database.

   - Execute `dotnet build` then `dotnet run`.
   - Use Swagger UI (`/swagger`) or tools like `curl`/`Postman` to call the endpoints against your SQL Server instance.
